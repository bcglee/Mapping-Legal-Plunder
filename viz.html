<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Lucca Debt</title>
        <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://unpkg.com/topojson@3"></script>
    </head>
    <!-- <body> -->
    <svg width="1000" height="400"></svg>
    <script type="text/javascript">
        var width = 1000;
        var height = 400;

        // define map projection
        var projection = d3.geoAlbers()
                .center([-2, 44])
                .rotate([347, 0])
                .parallels([35, 45])
                // .scale(10000)
                .scale(20000)
                .translate([width / 2, height / 2]);

        // define path generator
        var path = d3.geoPath()
                        .projection(projection);

        //defines the zoom function
        var zoom = d3.zoom()   //https://bl.ocks.org/iamkevinv/0a24e9126cd2fa6b283c6f2d774b69a2
                      .scaleExtent([0.5, 8])
                      .on("zoom", zoomed);

        // create svg element
        var svg = d3.select("svg"),
            margin = {right: 50, left: 50},
            width = +svg.attr("width") - margin.left - margin.right
            height = +svg.attr("height");

        //calls the zoom function
        svg.call(zoom);

        // state variable, to be changed by dropdown (future slider)
        var state = ({year: "1333"})

        d3.json("https://homes.cs.washington.edu/~akintilo/cse512/a3/italy.json").then(function(map) {
            svg.selectAll("path")
                .data(topojson.feature(map, map.objects.custom).features)
                .join("path")
                .attr("fill", "#3d3d3d")
                .attr("d", path);
        });

        // debt data
        d3.csv("DALME_datasets/lucca_debt.csv").then(function(data) {
            filtered_data = data.filter(row => isYear(row, state.year) && hasLocation(row));

            dots = svg.selectAll(".dot").data(filtered_data) // selection should be empty...
            enterdots = dots.enter()
                            .append("circle")
                            .attr("class", "dot")
                            .attr("cx", function(d) {
                                return projection([d["lon"], d["lat"] ])[0];
                            })
                            .attr("cy", function(d) {
                                return projection([d["lon"], d["lat"] ])[1];
                            })
                            .attr("r", 1)
                            .attr("fill", "red");

            // selector
            var select =  d3.select("body")
                .append("div")
                .append("select")

            select
                .on("change", function(d) {
                    var value = d3.select(this).property("value");
                    update(value);
                });

            // using a dropdown for now
            select.selectAll("option")
                .data(d3.map(data, function(d){ return d.date_year; }).keys()) // remove duplicate years
                .enter()
                .append("option")
                .attr("value", function(d) { return d; })
                .text(function(d) { return d; });

            function update(year) {
                state.year = year;
                var newData = data.filter(row => isYear(row, state.year) && hasLocation(row));
                // newData = newData.filter(row => hasLocation(row)); // remove rows w/o location data
                var duration = 750; // (total transition time)/2

                dots = svg.selectAll(".dot").data(newData);

                // make all dots disappear
                svg.selectAll(".dot")
                    .transition("leave")
                    .duration(duration)
                    .style("opacity", 0)
                    .attr("r", 0);

                // remove exit()
                dots.exit()
                    .transition("remove")
                    .duration(0)
                    .delay(duration)
                    .remove();

                // create points for enter()
                // dots.enter()
                //     .append("circle")
                //     .attr("class", "dot")
                //     .attr("fill", "red")
                //     .attr("r", 0);
                dots.enter()
                    .append("circle")
                    // .transition("move1") // may need to change name
                    // .duration(0)
                    // .delay(duration)
                    .attr("class", "dot")
                    .attr("cx", function(d) {
                        return projection([d["lon"], d["lat"] ])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d["lon"], d["lat"] ])[1];
                    })
                    .attr("fill", "red")
                    .style("opacity", 0)
                    .attr("r", 0);

                // move new data to correct position, make visible
                // dots.merge(dots)
                //     .transition("move") // use a 0ms transition w/ delay to
                //     // allow previous transition to finish
                //     .duration(0)
                //     .delay(duration)
                //     .attr("cx", function(d) {
                //         return projection([d["lon"], d["lat"] ])[0];
                //     })
                //     .attr("cy", function(d) {
                //         return projection([d["lon"], d["lat"] ])[1];
                //     })
                //     .transition("enter")
                //     .duration(duration)
                //     .attr("r", 1)
                //     .attr("fill", "red");
                dots.transition("move") // use a 0ms transition w/ delay to
                    // allow previous transition to finish
                    .duration(0)
                    .delay(duration)
                    .attr("cx", function(d) {
                        return projection([d["lon"], d["lat"] ])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d["lon"], d["lat"] ])[1];
                    });

                // dots.merge(dots)
                svg.selectAll(".dot")
                    .transition("enter")
                    .duration(duration)
                    .delay(duration)
                    .style("opacity", 1)
                    .attr("r", 1);
            }
        });

        function isYear(row, year) {
            return row.date_year === year;
        }

        function hasLocation(row) {
            if (row.lat === '') {
                console.log();
            }
            return row.lat !== '';
        }

        function zoomed() {
                         svg
                           .selectAll('path') // To prevent stroke width from scaling
                           .attr('transform', d3.event.transform);
                       }


    </script>
    <!-- </body> -->
</html>

<!DOCTYPE html>
<html lang="en">

<style>
    .bar rect {
        fill: steelblue;
    }

    .bar text {
        fill: #fff;
        font: 10px sans-serif;
    }
</style>

<head>
    <meta charset="utf-8">
    <title>Lucca Debt</title>
    <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
</head>
<!-- <body> -->
<div id="reset">
    <input name="reset" type="button" value="Reset Zoom" onclick="resetzoom()" />
</div>
<svg width="1000" height="450"></svg>
<script type="text/javascript">
    var width = 1000;
    var height = 450;

    // define map projections
    var initial_projection = d3.geoAlbers() // zoomed out overview of Italy
        .center([0, 42])
        .rotate([347, 0])
        .parallels([35, 45])
        .scale(2750)
        .translate([width / 2, height / 2]);

    var true_projection = d3.geoAlbers() // zoomed in on Lucca
        .center([-2, 44])
        .rotate([347, 0])
        .parallels([35, 45])
        .scale(10000)
        .translate([width / 2, height / 2]);

    // define path generators
    var initial_path = d3.geoPath()
        .projection(initial_projection);

    var true_path = d3.geoPath()
        .projection(true_projection);

    // create svg element
    var svg = d3.select("svg"),
        margin = { right: 50, left: 50 },
        width = +svg.attr("width") - margin.left - margin.right
    height = +svg.attr("height");

    var curr_transform;

    // defines the zoom function
    var zoom = d3.zoom()   //https://bl.ocks.org/iamkevinv/0a24e9126cd2fa6b283c6f2d774b69a2
        .scaleExtent([1, 8])
        .translateExtent([[0, 0], [width + margin.left + margin.right, height]])
        .on("zoom", zoomed);

    // sets dot size for plotting
    var dot_size = 2

    // calls the zoom function
    svg.call(zoom);

    // state variable, to be changed by dropdown (future slider)
    var state = ({ year: "1333" });

    // transition duration in ms for zoom on load
    load_transition_duration = 2500;
    // transition delay in ms for zoom on load
    load_transition_delay = 1500;

    // initial plottng of gray points for zoom
    d3.json("https://homes.cs.washington.edu/~akintilo/cse512/a3/italy.json").then(function (map) {
        d3.csv("data/unique_locations.csv").then(function (data) {
            // show map
            svg.selectAll("path")
                .data(topojson.feature(map, map.objects.custom).features)
                .join("path")
                .attr("fill", "#3d3d3d")
                .attr("d", initial_path);

            // show dots
            dots = svg.selectAll(".backdot").data(data) // selection should be empty...
            enterdots = dots.enter()
                .append("circle")
                .attr("class", "backdot")
                .attr("cx", function (d) {
                    return initial_projection([d["lon"], d["lat"]])[0];
                })
                .attr("cy", function (d) {
                    return initial_projection([d["lon"], d["lat"]])[1];
                })
                .attr("r", function(d) {
                    // return Math.log(d["ct"]+1);
                    return Math.sqrt(d["ct"]/20);
                })
                .attr("fill","gray")
                .attr("fill-opacity", .75);

            // zoom in on load
            svg.selectAll("path")
                .data(topojson.feature(map, map.objects.custom).features)
                .join("path")
                .transition("map_zoom") // ugly transition, ease-in-out would be better
                .delay(load_transition_delay)
                .duration(load_transition_duration)
                .attr("d", true_path);

            enterdots.transition("dot_zoom")
                .delay(load_transition_delay)
                .duration(load_transition_duration)
                .attr("cx", function (d) {
                    return true_projection([d["lon"], d["lat"]])[0];
                })
                .attr("cy", function (d) {
                    return true_projection([d["lon"], d["lat"]])[1];
                });
        });
    });

    // adds blue background in order to make water blue
    svg.append('rect')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height)
        .attr('fill', 'lightBlue');

    // PUTTING THE TIMELINE HISTOGRAM HERE!!!!!!!
    //USED THIS WEBSITE:  https://bl.ocks.org/EmbraceLife/eed2f62f855854739ddf5e572d4322ed

    var parseDate = d3.isoParse,
        formatCount = d3.format(",.0f");

    var margin = { top: 10, right: 30, bottom: 30, left: 30 },
        width = 1000 - margin.left - margin.right,
        height = 200 - margin.top - margin.bottom;

    var svg2 = d3.select("body").append("svg")
        .attr("class", "time_hist")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    // ---- date data scale-map to px --------------------------
    //   1. assign xScale a scaleTime func
    var xScale = d3.scaleTime()
        //   2. set input or date range
        .domain([new Date(1330, 0, 1), new Date(1345, 0, 1)])
        //   3. set output or px range
        .rangeRound([0, width]);


    var yScale = d3.scaleLinear()
        .range([height, 0]);

    var histogram = d3.histogram()

        // histogram func only use date value from each row of dataset
        // .value() is like a row function to d3.histogram()
        // as .row() to d3.tsv()
        .value(function (d) { return d.date_full; })
        .domain(xScale.domain())
        .thresholds(xScale.ticks(d3.timeMonth)); //note error with xScale(x1) in rect!!

    //from this:  https://stackoverflow.com/questions/40173533/customize-the-d3-month-or-year-tick-format
    var xAxis = d3.axisBottom(xScale)
        .tickFormat(function (date) {
            if (d3.timeMonth(date) < date) {
                return d3.timeFormat('%b')(date);
            } else {
                return d3.timeFormat('%Y')(date);
            }
        });

    svg2.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis)
        .selectAll(".tick text")
        .style("text-anchor", "start")
        .attr("x", 6)
        .attr("y", 6);

    // apply date format func to date value of each row of data
    function type(d) {
        d.date_full = parseDate(d.date_full);
        return d;
    }

    d3.csv("data/DALME_datasets/lucca_debt_full_dates_cleaned.csv", type).then(function (data) {
        d3.csv("data/unique_locations.csv").then(function (locations) {

        // ---- apply data to histogram func -------------
        // meaning: regroup all data into different bins
        var bins = histogram(data);
        // console.log(bins);

        yScale.domain([0, d3.max(bins, function (d) { return d.length; })]);


        var bar = svg2.selectAll(".bar")
            .data(bins)
            .enter().append("g")
            .attr("class", "bar")
            .attr("transform", function (d) { return "translate(" + xScale(d.x0) + "," + yScale(d.length) + ")"; });


        var rects = bar.append("rect")
            .attr("x", 1)
            .attr("width", function (d) { return xScale(d.x1) - xScale(d.x0) - 1; })
            .attr("height", function (d) { return height - yScale(d.length); });

        //https://bl.ocks.org/Fil/2d43867ba1f36a05459c7113c7f6f98a
        var brush = d3.brushX()
            .extent([[0, 0], [width, height]])
            .on("start brush end", brushmoved);
        var gBrush = svg2.append("g")
            .attr("class", "brush")
            .call(brush);
        var brushResizePath = function (d) {
            var e = +(d.type == "e"),
                x = e ? 1 : -1,
                y = height / 2;
            return "M" + (.5 * x) + "," + y + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y) + "Z" + "M" + (2.5 * x) + "," + (y + 8) + "V" + (2 * y - 8) + "M" + (4.5 * x) + "," + (y + 8) + "V" + (2 * y - 8);
        }
        var handle = gBrush.selectAll(".handle--custom")
            .data([{ type: "w" }, { type: "e" }])
            .enter().append("path")
            .attr("class", "handle--custom")
            .attr("stroke", "#000")
            .attr("cursor", "ew-resize")
            .attr("d", brushResizePath);

        gBrush.call(brush.move, [0.3, 0.5].map(xScale));

        function brushmoved() {
            var selection = d3.event.selection;
            if (selection == null) {
                handle.attr("display", "none");
                //circle.classed("active", false);
            } else {
                var e = d3.event.selection.map(xScale.invert, xScale);
                var newData = data.filter(function (d) {return e[0] <= d.date_full && e[1] >= d.date_full; });
                d3.selectAll('.foredot').remove(); // remove old foredots

                svg.selectAll('.foredot')
                    .data(locations)
                    .enter()
                    .append("circle")
                    .attr("class", "foredot")
                    .attr("cx", function (d) {
                        return true_projection([d["lon"], d["lat"]])[0];
                    })
                    .attr("cy", function (d) {
                        return true_projection([d["lon"], d["lat"]])[1];
                    })
                    .attr("transform", curr_transform)
                    .attr("r", function(d) {
                        return Math.sqrt(newData.filter(el => el["town"] === d["town"]).length/20);
                    })
                    .style("fill", "green");

                handle.attr("display", null).attr("transform", function (d, i) { return "translate(" + [selection[i], - height / 4] + ")"; });
            }
        }
      })
    });

    /* *** FUNCTIONS *** */

    //reset button for resetting zoom
    function resetzoom() {
        svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
    };

    // TODO: maybe use a different transition (fade out/in?) to avoid
    // misleading users into tinking shrinking is meaningful
    function update(year, data) {
        state.year = year;
        var newData = data.filter(row => isYear(row, state.year) && hasLocation(row));
        var duration = 750; // (total transition time)/2

        // make all dots disappear
        svg.selectAll(".backdot")
            // transition.remove() requires elements have no pending transitions,
            // so we change its class
            .attr("class", "old_dot")
            .transition("leave")
            .remove()
            .duration(duration)
            .style("opacity", 0)
            .attr("r", 0);

        dots = svg.selectAll(".backdot").data(newData)

        // create (invisible) points for enter()
        dots.enter()
            .append("circle")
            .attr("class", "backdot")
            .attr("cx", function (d) {
                return true_projection([d["lon"], d["lat"]])[0];
            })
            .attr("cy", function (d) {
                return true_projection([d["lon"], d["lat"]])[1];
            })
            .attr("transform", curr_transform)
            .attr("fill", "red")
            .style("opacity", 0)
            .attr("r", 0);

        // fade (unshrink?) points in
        svg.selectAll(".backdot")
            .transition("enter")
            .duration(duration)
            .delay(duration)
            .style("opacity", 1)
            .attr("r", dot_size);
    }

    function isYear(row, year) {
        return row.date_year === year;
    }

    function hasLocation(row) {
        return row.lat !== '';
    }

    // function for zooming
    function zoomed() {
        curr_transform = d3.event.transform;
        //transforms the map appropriately (with zoom)
        svg.selectAll('path')
            .attr('transform', d3.event.transform);

        //transforms the dots appropriately (with zoom)
        svg.selectAll(".backdot")
            .attr('transform', d3.event.transform);

        //transforms the dots appropriately (with zoom)
        svg.selectAll(".foredot")
            .attr('transform', d3.event.transform);
    };

</script>
<!-- </body> -->

</html>

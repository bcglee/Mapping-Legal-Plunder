<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Lucca Debt</title>
        <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://unpkg.com/topojson@3"></script>
    </head>
    <!-- <body> -->
    <div id="reset">
        <input name="reset"
               type="button"
               value="Reset Zoom"
               onclick="resetzoom()" />
    </div>
    <svg width="1000" height="600"></svg>
    <script type="text/javascript">
        var width = 1000;
        var height = 600;

        // define map projection
        var projection = d3.geoAlbers()
                .center([-2, 44])
                .rotate([347, 0])
                .parallels([35, 45])
                // .scale(10000)
                .scale(10000)
                .translate([width / 2, height / 2]);

        // define path generator
        var path = d3.geoPath()
                        .projection(projection);

        // create svg element
        var svg = d3.select("svg"),
            margin = {right: 50, left: 50},
            //width = svg.attr("width")
            width = +svg.attr("width") - margin.left - margin.right
            height = +svg.attr("height");

        var curr_transform; // stores current transform state

        // defines the zoom function
        var zoom = d3.zoom()   //https://bl.ocks.org/iamkevinv/0a24e9126cd2fa6b283c6f2d774b69a2
                     .scaleExtent([1, 8])
                     .translateExtent([[0,0], [width+margin.left+margin.right, height]])
                     .on("zoom", zoomed);

        // sets dot size for plotting
        var dot_size = 2

        // calls the zoom function
        svg.call(zoom);

        // state variable, to be changed by dropdown (future slider)
        var state = ({year: "1333"});

        // d3.json("https://homes.cs.washington.edu/~akintilo/cse512/a3/italy.json").then(function(map) {
        d3.json("maps/italy.json").then(function(map) {
            svg.selectAll("path")
                .data(topojson.feature(map, map.objects.custom).features)
                .join("path")
                .attr("fill", "#3d3d3d")
                .attr("d", path);
        });


        // sets center point for zoom upon load
        var centertest = [10.44889, 43.88762];


        svg.on("click", function() {
          var point = projection(centertest);
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
             //svg
             // .selectAll('path')
             // .attr('transform', d3.event.transform);
             //  svg
             //   .selectAll(".dot")
            //    .attr('transform', d3.event.transform);
              //.attr('transform', d3.zoomIdentity
              //                     .translate([width / 2 - point[0] * scale, height / 2 - point[1] * scale])
              //                     .scale(scale) ); // updated for d3 v4)



             //.call(zoom.transform, d3.zoomIdentity
            //                         .translate([width / 2 - point[0] * scale, height / 2 - point[1] * scale])
            //                         .scale(scale) ); // updated for d3 v4
          d3.event.stopPropagation();
        });

        //reset button for resetting zoom
        function resetzoom(){
          svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        };

        svg.append('rect')
           .attr('width', width+margin.left+margin.right)
           .attr('height', height)
           .attr('fill', 'lightBlue');

        // debt data
        d3.csv("DALME_datasets/lucca_debt.csv").then(function(data) {
            filtered_data = data.filter(row => isYear(row, state.year) && hasLocation(row));

            dots = svg.selectAll(".dot").data(filtered_data) // selection should be empty...
            enterdots = dots.enter()
                            .append("circle")
                            .attr("class", "dot")
                            .attr("cx", function(d) {
                                return projection([d["lon"], d["lat"] ])[0];
                            })
                            .attr("cy", function(d) {
                                return projection([d["lon"], d["lat"] ])[1];
                            })
                            .attr("r", dot_size)
                            .attr("fill", "red");

            // selector
            var select =  d3.select("body")
                .append("div")
                .append("select")

            select
                .on("change", function(d) {
                    var value = d3.select(this).property("value");
                    update(value);
                });

            // using a dropdown for now
            select.selectAll("option")
                .data(d3.map(data, function(d){ return d.date_year; }).keys()) // remove duplicate years
                .enter()
                .append("option")
                .attr("value", function(d) { return d; })
                .text(function(d) { return d; });

            // TODO: maybe use a different transition (fade out/in?) to avoid
            // misleading users into thinking shrinking is meaningful
            function update(year) {
                state.year = year;
                var newData = data.filter(row => isYear(row, state.year) && hasLocation(row));
                var duration = 750; // (total transition time)/2

                // make all dots disappear
                svg.selectAll(".dot")
                    // transition.remove() requires element have no pending transitions,
                    // so we change its class
                    .attr("class", "old_dot")
                    .transition("leave")
                    .remove()
                    .duration(duration)
                    .style("opacity", 0)
                    .attr("r", 0);

                dots = svg.selectAll(".dot").data(newData);
                
                // create (invisible) points for enter(), which is all of the new data
                dots.enter()
                    .append("circle")
                    .attr("class", "dot")
                    .attr("cx", function(d) {
                        return projection([d["lon"], d["lat"] ])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d["lon"], d["lat"] ])[1];
                    })
                    .attr('transform', curr_transform)
                    .attr("fill", "red")
                    .style("opacity", 0)
                    .attr("r", 0);

                // fade points in
                svg.selectAll(".dot")
                    .transition("enter")
                    .duration(duration)
                    .delay(duration)
                    .style("opacity", 1)
                    .attr("r", dot_size);
            }
        });

        function isYear(row, year) {
            return row.date_year === year;
        }

        function hasLocation(row) {
            return row.lat !== '';
        }

        //function for zooming
        function zoomed() {
            curr_transform = d3.event.transform; // used in update() as well
            //transforms the map appropriately (with zoom)
                svg
                .selectAll('path')
                .attr('transform', curr_transform);

            //transforms the dots appropriately (with zoom)
                svg
                .selectAll(".dot")
                .attr('transform', curr_transform);
        };


    </script>
    <!-- </body> -->
</html>

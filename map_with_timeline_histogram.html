<!DOCTYPE html>
<html lang="en">

  <style>
  .bar rect  {
    fill: steelblue;
  }
  .bar text {
    fill: #fff;
    font: 10px sans-serif;
  }
  </style>

    <head>
        <meta charset="utf-8">
        <title>Lucca Debt</title>
        <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://unpkg.com/topojson@3"></script>
    </head>
    <!-- <body> -->
    <div id="reset">
        <input name="reset"
               type="button"
               value="Reset Zoom"
               onclick="resetzoom()" />
    </div>
    <svg width="1000" height="600"></svg>
    <script type="text/javascript">
        var width = 1000;
        var height = 600;

        // define map projection
        var projection = d3.geoAlbers()
                .center([-2, 44])
                .rotate([347, 0])
                .parallels([35, 45])
                // .scale(10000)
                .scale(10000)
                .translate([width / 2, height / 2]);

        // define path generator
        var path = d3.geoPath()
                        .projection(projection);

        // create svg element
        var svg = d3.select("svg"),
            margin = {right: 50, left: 50, top:10, bottom:10},
            //width = svg.attr("width")
            width = +svg.attr("width") - margin.left - margin.right
            height = +svg.attr("height");

        // defines the zoom function
        var zoom = d3.zoom()   //https://bl.ocks.org/iamkevinv/0a24e9126cd2fa6b283c6f2d774b69a2
                     .scaleExtent([1, 8])
                     .translateExtent([[0,0], [width+margin.left+margin.right, height]])
                     .on("zoom", zoomed);

        // sets dot size for plotting
        var dot_size = 2

        // calls the zoom function
        svg.call(zoom);

        // state variable, to be changed by dropdown (future slider)
        var state = ({year: "1333"});

        d3.json("https://homes.cs.washington.edu/~akintilo/cse512/a3/italy.json").then(function(map) {
            svg.selectAll("path")
                .data(topojson.feature(map, map.objects.custom).features)
                .join("path")
                .attr("fill", "#3d3d3d")
                .attr("d", path);
        });


        // sets center point for zoom upon load
        var centertest = [10.44889, 43.88762];


        svg.on("click", function() {
          var point = projection(centertest);
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
             //svg
             // .selectAll('path')
             // .attr('transform', d3.event.transform);
             //  svg
             //   .selectAll(".dot")
            //    .attr('transform', d3.event.transform);
              //.attr('transform', d3.zoomIdentity
              //                     .translate([width / 2 - point[0] * scale, height / 2 - point[1] * scale])
              //                     .scale(scale) ); // updated for d3 v4)



             //.call(zoom.transform, d3.zoomIdentity
            //                         .translate([width / 2 - point[0] * scale, height / 2 - point[1] * scale])
            //                         .scale(scale) ); // updated for d3 v4
          d3.event.stopPropagation();
        });

        //reset button for resetting zoom
        function resetzoom(){
          svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        };

        svg.append('rect')
           .attr('width', width+margin.left+margin.right)
           .attr('height', height)
           .attr('fill', 'lightBlue');

        // debt data
        d3.csv("data/DALME_datasets/lucca_debt.csv").then(function(data) {
            filtered_data = data.filter(row => isYear(row, state.year) && hasLocation(row));
          
            dots = svg.selectAll(".dot").data(filtered_data) // selection should be empty...
            enterdots = dots.enter()
                            .append("circle")
                            .attr("class", "dot")
                            .attr("cx", function(d) {
                                return projection([d["lon"], d["lat"] ])[0];
                            })
                            .attr("cy", function(d) {
                                return projection([d["lon"], d["lat"] ])[1];
                            })
                            .attr("r", dot_size)
                            .attr("fill", "red");

            // selector
            var select =  d3.select("body")
                .append("div")
                .append("select")

            select
                .on("change", function(d) {
                    var value = d3.select(this).property("value");
                    update(value);
                });

            // using a dropdown for now
            select.selectAll("option")
                .data(d3.map(data, function(d){ return d.date_year; }).keys()) // remove duplicate years
                .enter()
                .append("option")
                .attr("value", function(d) { return d; })
                .text(function(d) { return d; });

            function update(year) {
                state.year = year;
                var newData = data.filter(row => isYear(row, state.year) && hasLocation(row));
                // newData = newData.filter(row => hasLocation(row)); // remove rows w/o location data
                var duration = 750; // (total transition time)/2

                dots = svg.selectAll(".dot").data(newData);

                // make all dots disappear
                svg.selectAll(".dot")
                    .transition("leave")
                    .duration(duration)
                    .style("opacity", 0)
                    .attr("r", 0);

                // remove exit()
                dots.exit()
                    .transition("remove")
                    .duration(0)
                    .delay(duration)
                    .remove();

                // create points for enter()
                // dots.enter()
                //     .append("circle")
                //     .attr("class", "dot")
                //     .attr("fill", "red")
                //     .attr("r", 0);
                dots.enter()
                    .append("circle")
                    // .transition("move1") // may need to change name
                    // .duration(0)
                    // .delay(duration)
                    .attr("class", "dot")
                    .attr("cx", function(d) {
                        return projection([d["lon"], d["lat"] ])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d["lon"], d["lat"] ])[1];
                    })
                    .attr("fill", "red")
                    .style("opacity", 0)
                    .attr("r", 0);

                // move new data to correct position, make visible
                // dots.merge(dots)
                //     .transition("move") // use a 0ms transition w/ delay to
                //     // allow previous transition to finish
                //     .duration(0)
                //     .delay(duration)
                //     .attr("cx", function(d) {
                //         return projection([d["lon"], d["lat"] ])[0];
                //     })
                //     .attr("cy", function(d) {
                //         return projection([d["lon"], d["lat"] ])[1];
                //     })
                //     .transition("enter")
                //     .duration(duration)
                //     .attr("r", 1)
                //     .attr("fill", "red");
                dots.transition("move") // use a 0ms transition w/ delay to
                    // allow previous transition to finish
                    .duration(0)
                    .delay(duration)
                    .attr("cx", function(d) {
                        return projection([d["lon"], d["lat"] ])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d["lon"], d["lat"] ])[1];
                    });

                // dots.merge(dots)
                svg.selectAll(".dot")
                    .transition("enter")
                    .duration(duration)
                    .delay(duration)
                    .style("opacity", 1)
                    .attr("r", dot_size);
            }
        });

        function isYear(row, year) {
            return row.date_year === year;
        }

        function hasLocation(row) {
            if (row.lat === '') {
                console.log();
            }
            return row.lat !== '';
        }

        //function for zooming
        function zoomed() {
                        //transforms the map appropriately (with zoom)
                          svg
                           .selectAll('path')
                           .attr('transform', d3.event.transform);

                        //transforms the dots appropriately (with zoom)
                          svg
                           .selectAll(".dot")
                           .attr('transform', d3.event.transform);
                       };



// PUTTING THE TIMELINE HISTOGRAM HERE!!!!!!!
//USED THIS WEBSITE:  https://bl.ocks.org/EmbraceLife/eed2f62f855854739ddf5e572d4322ed

var parseDate = d3.isoParse,
  formatCount = d3.format(",.0f");

var margin = {top: 10, right: 30, bottom: 30, left: 30},
  width = 1000 - margin.left - margin.right,
  height = 500 - margin.top - margin.bottom;

var svg2 = d3.select("body").append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
.append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");



// ---- date data scale-map to px --------------------------
//   1. assign xScale a scaleTime func
var xScale = d3.scaleTime()
// 	 2. set input or date range
  .domain([new Date(1330, 0, 1), new Date(1345, 0, 1)])
// 	 3. set output or px range
  .rangeRound([0, width]);


var yScale = d3.scaleLinear()
  .range([height, 0]);

var histogram = d3.histogram()

// histogram func only use date value from each row of dataset
// .value() is like a row function to d3.histogram()
// as .row() to d3.tsv()
  .value(function(d) { return d.date_full; })
  .domain(xScale.domain())
  .thresholds(xScale.ticks(d3.timeWeek)); //note error with xScale(x1) in rect!!

//from this:  https://stackoverflow.com/questions/40173533/customize-the-d3-month-or-year-tick-format
var xAxis = d3.axisBottom(xScale)
  .tickFormat(function(date){
    if (d3.timeMonth(date) < date) {
      return d3.timeFormat('%b')(date);
    } else {
      return d3.timeFormat('%Y')(date);
    }
  });

    svg2.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis)
      .selectAll(".tick text")
        .style("text-anchor", "start")
        .attr("x", 6)
        .attr("y", 6);

// apply date format func to date value of each row of data
function type(d) {
d.date_full = parseDate(d.date_full);
console.log(d.date_full)
return d;
}
// import data here


d3.csv("data/DALME_datasets/lucca_debt_full_dates_cleaned.csv",type).then(function(data) {

// ---- apply data to histogram func -------------
// meaning: regroup all data into different bins
var bins = histogram(data);
// console.log(bins);

yScale.domain([0, d3.max(bins, function(d) { return d.length; })]);


var bar = svg2.selectAll(".bar")
    .data(bins)
    .enter().append("g")
    .attr("class", "bar")
    .attr("transform", function(d) { return "translate(" + xScale(d.x0) + "," + yScale(d.length) + ")"; });


var rects =  bar.append("rect")
    .attr("x", 1)
    .attr("width", function(d) { return xScale(d.x1) - xScale(d.x0) - 1;})
    .attr("height", function(d) { console.log(height); return height - yScale(d.length); });

//bar.append("text")
//    .attr("dy", ".75em")// trial and error
//    .attr("y", 6) // text backdown 6 px
//    .attr("x", function(d) { return (xScale(d.x1) - xScale(d.x0)) / 2; })
//    .attr("text-anchor", "middle")
//    .text(function(d) { return formatCount(d.length); });
});




    </script>
    <!-- </body> -->
</html>
